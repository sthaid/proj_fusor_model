DATA
- array of particles
- particles indexed by cu mm location, needs a list or an array at each location
- radial stats

INTERACTIONS
- ionization
- recombination
- collision
- movement
  . if goes outside chamber then reset speed to ambient temperature, and
    reset direction to within chamber, and reset position to within chamber

PARAMETERS
- chamber radius   
- grid radius
- grid voltage
- grid current
- pressure, can this be changed dynamically
- delta_t  (warn if becomes too big to process collisions)

CONSTANTS
- number of particles in the simulation
- location box size  (cu mm)

GRAPHS - X AXIS IS RADIUS
- number density of D and D ions
- temperature
- ionization and recombination rate

CHAMBER VIEW
- cross section xl to xh, yl to yh, z-deltaz/2 to z+deltaz/2
- ability to set deltaz, and to zoom in and out on an x,y

PROGRAMMING
- use integer math
  . x,y,z:  nanometers
  . velocity:  nanometers/sec
  . time:  nanoseconds
- use all available cores for particle sim
- main thread is for sdl display and control
- files
  . common.h
  . main.c
  . ionization.c
  . particles.c
  . readme
- locking
  . each thread will grab a location to process all particles at that
    location, and while doing that will own the mutex for that location
  . if a particle has moved into a location it will have already have been
    processed for this T, and thus will not be reporcessed
  . when moving a particle to a new location, will need to acquire the lock
    for that location

ASSUMPTIONS
- only D, no D2

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx





#if 0 // LATER
#define FILE_HDR_MAGIC    1234567
#define FILE_HDR_VERSION  1

typedef struct {
    int64_t magic;
    int64_t version;
    int64_t reserved[6];
} file_hdr_t;

int32_t model_init_from_file()
{
    int32_t fd = -1;
    int32_t ret = -1;
    bool was_running;

    // stop the model
    was_running = model_stop();

    // open the file
    fd = open(xxx, O_RDONLY);
    if (fd == -1) {
        ERROR
        goto err;

    // read file header and verify
    ret = read(fd, &hdr, sizeof(hdr));
    if (ret != sizeof(hdr)) {
        ERROR
        goto err;
    }

    // read ....................

    // success
    ret = 0;
    goto cleanup;

    // error 
err:
    ret = -1;
    goto cleanup;

    // cleanup and return
cleanup:
    if (fd != -1) {
        close(fd);
    }
    if (was_running) {
        model_start();
    }
    return ret;
}

int32_t model_write_file(void)
{
    bool was_running;

    // stop the model
    was_running = model_stop();

    // write the file

    // if the model was running then start the model
    if (was_running) {
        model_start();
    }
}


int32_t model_terminate()
{
    // stop the model

    // XXX what else?
}


model_change_param(enum param_select, int64_t param_value)
{
    // if the model is running then stop the model

    // change the param
    switch (param_select) {
    case PARM_VOLTAGE:
        param.voltage = param_value;
        break;
    ...
    }

    // if the model was running then start the model
}
#endif
